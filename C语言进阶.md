### C语言进阶
---
# 数据存储_数据类型

常见数据类型的内存大小
```
char	1
short	2
int		4
long	4/8取决平台位数
longlong	8		C99规范下
float		4
double	8
```
类型可以归类为五个基本情况:
> ## 整形家族
>  包括char , short , int ,  long的有符号和无符号版本

>## 浮点数家族
>float , double等

>## 构造类型
>如数组类型（个数不同也属于不同类型），结构体struct，枚举类型enum，联合类型union。

>## 指针类型


>## 空类型
>void，表示无类型。注意void*是属于指针类型的。

下面我们进行区别的讲解：

----

## 整形在内存中的存储

正数的二进制标售有三种
1. 正数的三者相同
2. 负数的三者需要计算

- 原码 : 直接写出的二进制序列
- 反码 : 符号位不变 , 其他按位取反
- 补码 : 反码+1

为什么要用补码？--》可以把符号位和数字域统一处理，补码和源码的互相转化运算过程是相同的，不需要额外的硬件电路。 

---

## 大小端

 大小端字节序存储，大端时高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。小段反之，字面意思就是大端正着放( 注意,11 22 33 44这个数据,44是其低位,对应大端则44放在低地址 )，小端反着放。
 这里补充C语言中内存空间布局：
 ```
最高内存地址 0xFFFFFFFF

栈区（从高内存地址，往 低内存地址发展。即栈底在高地址，栈顶在低地址）

堆区（从低内存地址 ，往 高内存地址发展）

全局区（常量和全局变量）

代码区

最低内存地址 0x00000000
```
这时候就有人想问了，该怎么判断使用的是哪种字节序呢？考虑这个代码
```c
int a = 1;
///如果是大端 为01 00 00 00
///如果是小端 为00 00 00 01

///因此,把a的地址转为char*,只取一个char大小,看看取出来的是00 还是 01
if(  *(char*)&a == 1)
///先强制类型转换 &a 为字符串类型的指针char*,然后再对他解引用。
{
...

}

```
 ### 数据类型存储
---
我们知道，计算机在存储数据时往往采用补码的方式，而当发生类型转换时，又会进行整型提升和截断等。
比如：
```c
char a = -128
///char并没有规定默认有无符号,但是常见编辑器都是默认有符号的
///这里先发生-128  -> 100...10000000的32位整型存储
///再除了符号位翻转再加一,得到1111...10000000的补码
///最后存放到char里面,只有八位,发生高位截断,也即10000000存到a里面了
printf("%u\n" , a);
///要输出为无符号整型,就需要对a整型提升,对于有符号的char a,高位全部补齐为1.
///最后得到的,111....10000000整体被当成一个无符号整形打印出来.
但是注意!
如果char a = 128,在截断后与-128没区别,都是10000000
因此->
printf("%d\n",a);
///这里想用有符号整型打印,但是我们知道,系统中整型按照补码存储的,因此计算机进行如下解读:
收到111...10000000,视为补码,减一再取反
得到100...10000000,打印-128,完全大相径庭.
```

### 浮点储存
当我们尝试将int类型和float类型的数据和指针互相套用时,会出现答非所问的结果,这暗示着C语言对于二者有着截然不同的储存规则。

```
根据国际规范，一个二进制浮点数V可以表示为：
（-1）^S * M * 2^E
其中S的1或0反应正负，M表示有效数字，大于一小于二。2的E次方则是指数位(因为是二进制,底数是二才对嘛)。

举个例子，有V = 9.5f
二进制为---> 1001.1	(很神奇吧,2^-1 就是0.5)
转化为"科学计数法的浮点"  -- > (-1)^0 * 1.0011 * 2^3
即 S = 0 	;	 M = 1.0011 	;		 E = 3;
```
>同时,这里我们就会发现一件事情，也就是为什么float存储时会发生精度丢失，我们知道小数的二进制是靠不断×2取小数部分再重复的，显然诸如 0.3 的小数，会经历 0.6 -》 0.2 —》0.4 -》0.8 -》0.6的死循环，这也就意味着它没有准确的二进制对应，那么计算机尝试到某个地方怕溢出就索性拉倒了，截断完事。

知道了S M E的存储规则，我们就可以了解浮点数的存储了。根据规范,对于32位浮点数的单精度存储：
| S | E | M|
|--|--|--|
|符号|指数|有效数字|
|1  | 8 |23 |

单位是bit位。
这里有一些规范，首先知道M有效数字永远是1.xxxx，那么这个1一般可以忽略，直接存储小数部分。E规范为无符号整形，但是实际情况下会有问题。为什么？因为这是二进制，哪怕是0.5D  == 0.1B，最后得到一个1.0的 M 和-1的 E。

这时候就有人说了，哎呀我敲，你都知道有负数了怎么还是无符号整型呢，因此规定存储E时需要进行*中间移位*，也即加上中间数，对于8bit（float）的指数位，我们加上127。对于32位的（double），我们加1023上去。
那么我们回到最开始：
```
float f = 5.5 ;
5.5D -> 101.1B
(-1)^0  *  1.011  *  2^2
s=0 ; m=1.011 ; e = 2;
2 + 127 = 129d = 1000 0001b
存储为0 10000001 1011 0000000000000000000
0100 0000 1101 10000000000000000000
=0x
```
  
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTkzMTY4MTI5NSwtNjU4ODcyNTgyLDE3OD
gzMzUyOThdfQ==
-->