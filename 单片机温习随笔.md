# 单片机学习随笔
---

使用库函数配置寄存器-->略,总之Start启动文件和Library的库文件复制进去就好,User里面放it的c,h文件和conf.h( 主要是将芯片涉及到的外设头文件全部组织在一起 )，

下面是初始化使用的函数：

>RCC_APB2PeriphClockCmd（RCC_APB2Periph_GPIOX , ENABLE）使能外设时钟,本质上是脚本化配置RCC_APBENR这个寄存器。

```c
GPIO_Init(GPIO_TypeDef *GPIOx ， GPIO_InitTyepeDef * GPIO_InitSruct);

举例:
///结构体具体的成员需要查找其定义寻找,例如GPIO_Mode查找定义去找到一系列GPIO输出模式
RCC_APBPeriphClockCmd( RCC_APB2Periph_GPIOA , ENABLE );
GPIOInitTypeDef GPIO_InitStructure;
//RCC_PB2的外设高速时钟配置


////这里的GPIOInitTypeDef 是对一类结构体()也即包含Pin,Speed,Mode的这种进行的TypeDef,这里声明了一个GPIO_InitStructure名字的这种类型的结构体
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	//通用推挽输出
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
GPIO_InitStructure.Speed = Gpio_Speed_50MHz;
///然后就可以初始化GPIO了
GPIO_Init( GPIOC , &GPIO_InitStructure ) ;
GPIO_SetBits( GPIOC , GPIO_Pin_13 ) ;
//当然,这里会发现我们偶尔也会用结构体指针来接收,所以用'结构体地址->结构体成员'就会很方便.

## 以上就是一个完整的GPIO端口初始化

```
---

## UART  （通用*异步*收发器）

##### 串口的数据帧格式
> 起始位 1位
> 数据位 8/9位
> 停止位 0.5-2位
---
传输过程
**开始时为高位(空闲),
发送方先将数据线拉低作为起始位	随后传输数据位,低电平为0,高电平为1.	
最后拉高数据线电压作为停止位,一般都是1位长度,标志着数据线再次进入空闲状态.**
>*我们一般习惯以字节为单位传输数据,因此数据位常见的格式是*
- 9位长,带一位校验位
- 8位长,不带校验位
#### 其中,校验位分为奇偶校验
<font color=red>分别代表着补上校验位后数据位中有奇偶个'1'


----
### 波特率
>每秒钟传输位的数量,如9600波特率,传输一位所需时间就为1/9600

----
使用HAL_UART_Transmit
```c
HAL_UART_Transmit(*huart , *pData , Size, Timeout)
///三者所需类型为UART_HandleTypeDef	8位无符号	16位无符号	32位无符号整型
*ps：这个函数会返回timeout后的接受结果，一般都是HAL_OK*
例如:

char *str = "你好~"
HAL_UART_Transmit(&huart1 , (uint8_t *)str , strlen(str) , HAL_MAX_DELAY);
```
 同样的，有类似的接收函数HAL_UART_Receive
 ```c
HAL_UART_Receive(*huart , *pData , Size, Timeout)
这里*pData是指向接受缓冲区的指针。
可以使用uint8_t receiveData[10]
这样的数组来作为缓冲区
```
----
---

# 总线 -  I2C
串口确实好用,但是往往一台单片机只能连接有限个通讯设备,这时就需要总线通讯了!
>I2C由两根数据线SCL^串行时钟线SerialClock^与SDA^串行数据线SerialData^组成.
>
>将主机从机的两根线分别连接在SCL与SDA总线上,再在总线上分别连接一个4.7k阻值连接Vdd的上拉电阻
>
>主机从机两个引脚都设置为***开漏***输出

为什么要使用这种设计呢?其实是为了逻辑线与,让我们思考一下--
>当io口全部写入1时,由于开漏的设置,反馈为高阻抗(开路),导致SCL/SDA总线悬空,而上拉电阻线路的存在使得其输出高电平

>任意io口写入一个0时,总线通过写0的引脚接地,上拉电路被无视,从而输出低电平.

好神奇我测:sweat_smile:

SDA上的数据要求在SCL高电平时保持稳定,SCL低电平时再改变

---
#### I2C的流程
分为四步 ***起始位 寻址 数据传输 停止位***
>### 起始:
>	由于上拉电阻,SCL与SDA都是高电压,主机先主动下拉SDA作为起始位

>### 寻址:
>	主机向总线发送从机地址,从主机开始向SDA写入数据的瞬间,SCL激活~也即被拉低~,然后开始锯齿状传输时钟信号.	常用是7位地址.剩下的一位^R/W#,井号代表低电压有效,即0写1读^代表数据传输的方向,随后主机释放SDA等待从机应答,从机把SDA拉低发送应答信号ACK(acknowledge)

这里可能会想,如果从机是0x11的话,岂不是最后一位冲突了?需要注意的是,从机的地址我们就是设计为了7位,并不是按照字节为单位,``用十六进制描述从机地址时,默认它代表的是 7 位二进制数.``也即0x11 -> 十进制17 -> 七位二进制0001001
>
>在从机应答过程中,可能无法ACK,这称为NAK,寻址失败有这些可能
>- 地址错误
>- 从机忙
>- 从机故障

>### 数据接收
>以字节为单位,同样是发送方结束后拉高,等待接收方拉低SDA作为ACk信号.

>### 停止位
>由主机发送,在SCL为1时,向SDA发送上升沿信号结束.

### 程序部分

引入新的函数:
```c
HAL_I2C_Master_Transmit(*hi2c , DevAddress , *pData , Size , Timeout)

举例,为了点亮oled,要对其初始化发送一串数据
uint8_t commands = {0x00 , 0x8d, ....};
HAL_I2C_Master_Transmit(&hi2c1 , 0x78 , commands , sizeof(commands)/sizeof(commands[0]) , HAL_MAX_DELAY);

```
<!--stackedit_data:
eyJoaXN0b3J5IjpbLTE1NjkwODIxMTksLTEyNzc5NDk5NzEsLT
g4MzkyMjEyOCw4MzY1MTEzOTksLTIxMjEzODczNjksLTUxNTc1
OTcxOSwxNDAxNTc3MzEyLDEyOTk4MDE2MjAsMTU5MDcxNjM1OC
wtOTYxNzg2NDgyLC0xMzg0MjY0NDk2LDgwNjQ0MjExMiwxNTA0
MTE4NTAyLC0xOTk0NjA5ODAsLTExNzM4NjQ2NjddfQ==
-->