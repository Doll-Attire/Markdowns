### C语言进阶
---
# 数据存储_数据类型

常见数据类型的内存大小
```
char	1
short	2
int		4
long	4/8取决平台位数
longlong	8		C99规范下
float		4
double	8
```
类型可以归类为五个基本情况:
> ## 整形家族
>  包括char , short , int ,  long的有符号和无符号版本

>## 浮点数家族
>float , double等

>## 构造类型
>如数组类型（个数不同也属于不同类型），结构体struct，枚举类型enum，联合类型union。

>## 指针类型


>## 空类型
>void，表示无类型。注意void*是属于指针类型的。

下面我们进行区别的讲解：

----

## 整形在内存中的存储

正数的二进制标售有三种
1. 正数的三者相同
2. 负数的三者需要计算

- 原码 : 直接写出的二进制序列
- 反码 : 符号位不变 , 其他按位取反
- 补码 : 反码+1

为什么要用补码？--》可以把符号位和数字域统一处理，补码和源码的互相转化运算过程是相同的，不需要额外的硬件电路。 

---

## 大小端

 大小端字节序存储，大端时高位字节排放在内存的低地址端，低位字节排放在内存的高地址端。小段反之，字面意思就是大端正着放( 注意,11 22 33 44这个数据,44是其低位,对应大端则44放在低地址 )，小端反着放。
 这里补充C语言中内存空间布局：
 ```
最高内存地址 0xFFFFFFFF

栈区（从高内存地址，往 低内存地址发展。即栈底在高地址，栈顶在低地址）

堆区（从低内存地址 ，往 高内存地址发展）

全局区（常量和全局变量）

代码区

最低内存地址 0x00000000
```
这时候就有人想问了，该怎么判断使用的是哪种字节序呢？考虑这个代码
```c
int a = 1;
///如果是大端 为01 00 00 00
///如果是小端 为00 00 00 01

///因此,把a的地址转为char*,只取一个char大小,看看取出来的是00 还是 01
if(  *(char*)&a == 1)
///先强制类型转换 &a 为字符串类型的指针char*,然后再对他解引用。
{
...

}

```
 ### 数据类型存储
---
我们知道，计算机在存储数据时往往采用补码的方式，而当发生类型转换时，又会进行整型对齐。
比如：
```c
char a = -128
///char并没有规定默认有无符号,但是常见编辑器都是默认有符号的
///这里先发生-128  -> 100...10000000的32位整型存储
///再除了符号位翻转再加一,得到1111...10000000的补码
///最后存放到char里面,只有八位,也即10000000存到a里面了
printf()
```


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTYyODAzODMwMiwxNDc4MDY4ODA1LC0yMD
U5NTE0NDY4LC03MTE0MTQxNSwxMjExMDE4Mjk5LC0xNTc4NDY3
OTU4LDE0NzYzNTQ3NzAsLTQwOTc5ODU0LC02OTc3NzM4MzAsLT
IxMjEzNjY4ODRdfQ==
-->