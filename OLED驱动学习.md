
>## SSD1306和I2C驱动的128*64OLED显示屏学习

 总体流程:
 1. 通过引出引脚,将内容发给驱动芯片
 2. 芯片存起来(自带RAM)
 3. 芯片自带时钟和扫描电路,根据显示存储器的数据自动刷新到屏幕

---
> SSD1306介绍
- 内置显示存储器GDDRAM: 128 * 64bit的SRAM,也即128 * 8 字节
- 两个电源 VDD1.65 ~ 3.3V用于ic逻辑;  VCC7~15V用于面板驱动,模块内部自带升压和降压芯片,因此不用考虑
- 支持8位并行接口,但是比较繁琐,一般用``串行``的3或4线的SPI接口或者I2C接口 ``一次发送一个bit,发送8次一字节`` 

引脚中值得注意的有BS0 ~ BS2为选择通信接口 , D0-D7为不同通信接口所需数据线,8位并行全部使用,串行的如I2C部分使用，D0为SCL，D1为SDAin，D2为SDAout。D/C#引脚在I2C下配置从机地址最低位，对命令和数据的筛别处理在数据线上。

> I2C

基础的略过。起始条件，终止条件，发送|接受数据，发送|接受应答--六大时序单元。在之前我们提到过，这分别是7位从设备地址+1位R/W#读写位，然后加上一个ACK信号，随即是8位寄存器地址，然后ACK。CO置1，可以连续发送命令+数据的组合，反之，只接受一次命令，随后连续接受数据

具体步骤是，起始之后SCL在低电平，主机在SCL低电平时，允许改变SDA的电平，随后主机松手SCL，使其回弹高电平，从机需要再此时迅速读取SDA，不断重复这个过程，传输的数据高位先

> OLED的设置
> 
本次操作使用的128*8Byte的显示屏，在纵向上的y轴自然也分为了8个一Byte长的“页Page”，顾名思义横向x轴有128bit。我们定义左上角为原点。展开后高位在y轴下方，例如写入0x55，则下到上为``0101 0101``。每次写完一位,内部地址指针自动右移一个单位。写到127行后，默认返回设定Page横轴的开头。可以配置寻址模式来实现自动到下一Page。但是你会发现，如果想要实现Y轴任意指定，会涉及到跨Page的情况，需要并行模式下读取GDDRAM的能力，串行模式下，需要缓存数组来中转最后一起写入，这里暂时不表。

>命令表

我们可以通过修改D/C位为0来写入命令给芯片，SSD1306会查找命令表并执行操作，命令可以由一个以上的字节组成。分为``寻址命令，基础命令，滚屏命令，硬件配置命令，时间与驱动命令``五大类。
这里给出三个常用单字节寻址命令
``00~0f，也即0000 xxxx，在页寻址模式下设置起始列地址低位``
``10~1f，和上面这个配合使用，设置高位，防止命令重合``
``B0~B7，1011 0xxx，设置页地址0_to_7``
这时候就有人说了哎哟我怎么这么多命令，上电得写死过去。还好搞硬件就是得会抄，可以参照手册配置发挥一下开源技术。

> ## 代码编写部分

分为两种。第一种不使用缓存区，直接改变GDDRAM，但也不能跨Page操作。第二种使用缓存区和占用一部分RAM空间，换来自定义的刷新和显示。

## 直接写入GDDRAM


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTc4ODM4MTUzNSw2NjE5MDgyNDAsMjA5MT
AwMjk2OF19
-->