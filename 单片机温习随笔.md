# 单片机学习随笔
---

使用库函数配置寄存器-->略,总之Start启动文件和Library的库文件复制进去就好,User里面放it的c,h文件和conf.h( 主要是将芯片涉及到的外设头文件全部组织在一起 )，

下面是初始化使用的函数：

>RCC_APB2PeriphClockCmd（RCC_APB2Periph_GPIOX , ENABLE）使能外设时钟,本质上是脚本化配置RCC_APBENR这个寄存器。

```c
GPIO_Init(GPIO_TypeDef *GPIOx ， GPIO_InitTyepeDef * GPIO_InitSruct);

举例:
///结构体具体的成员需要查找其定义寻找,例如GPIO_Mode查找定义去找到一系列GPIO输出模式
RCC_APBPeriphClockCmd( RCC_APB2Periph_GPIOA , ENABLE );
GPIOInitTypeDef GPIO_InitStructure;
//RCC_PB2的外设高速时钟配置


////这里的GPIOInitTypeDef 是对一类结构体()也即包含Pin,Speed,Mode的这种进行的TypeDef,这里声明了一个GPIO_InitStructure名字的这种类型的结构体
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	//通用推挽输出
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
GPIO_InitStructure.Speed = Gpio_Speed_50MHz;
///然后就可以初始化GPIO了
GPIO_Init( GPIOC , &GPIO_InitStructure ) ;
GPIO_SetBits( GPIOC , GPIO_Pin_13 ) ;
//当然,这里会发现我们偶尔也会用结构体指针来接收,所以用'结构体地址->结构体成员'就会很方便.

## 以上就是一个完整的GPIO端口初始化

```
---

## UART  （通用*异步*收发器）

##### 串口的数据帧格式
> 起始位 1位
> 数据位 8/9位
> 停止位 0.5-2位
---
传输过程
**开始时为高位(空闲),
发送方先将数据线拉低作为起始位	随后传输数据位,低电平为0,高电平为1.	
最后拉高数据线电压作为停止位,一般都是1位长度,标志着数据线再次进入空闲状态.**
>*我们一般习惯以字节为单位传输数据,因此数据位常见的格式是*
- 9位长,带一位校验位
- 8位长,不带校验位
#### 其中,校验位分为奇偶校验
<font color=red>分别代表着补上校验位后数据位中有奇偶个'1'


----
### 波特率
>每秒钟传输位的数量,如9600波特率,传输一位所需时间就为1/9600

----
使用HAL_UART_Transmit
```c
HAL_UART_Transmit(*huart , *pData , Size, Timeout)
///三者所需类型为UART_HandleTypeDef	8位无符号	16位无符号	32位无符号整型
*ps：这个函数会返回timeout后的接受结果，一般都是HAL_OK*
例如:

char *str = "你好~"
HAL_UART_Transmit(&huart1 , (uint8_t *)str , strlen(str) , HAL_MAX_DELAY);
```
 同样的，有类似的接收函数HAL_UART_Receive
 ```c
HAL_UART_Receive(*huart , *pData , Size, Timeout)
这里*pData是指向接受缓冲区的指针。
可以使用uint8_t receiveData[10]
这样的数组来作为缓冲区
```
----
---

# 总线 -  I2C
串口确实好用,但是往往一台单片机只能连接有限个通讯设备,这时就需要总线通讯了!
>I2C由两根数据线SCL^串行时钟线SerialClock^与SDA^串行数据线SerialData^组成.
>
>将主机从机的两根线分别连接在SCL与SDA总线上,再在总线上分别连接一个4.7k阻值连接Vdd的上拉电阻
>
>主机从机两个引脚都设置为***开漏***输出

为什么要使用这种设计呢?其实是为了逻辑线与,让我们思考一下--
>当io口全部写入1时,由于开漏的设置,反馈为高阻抗(开路),导致SCL/SDA总线悬空,而上拉电阻线路的存在使得其输出高电平

>任意io口写入一个0时,总线通过写0的引脚接地,上拉电路被无视,从而输出低电平.

好神奇我测:sweat_smile:

SDA上的数据要求在SCL高电平时保持稳定,SCL低电平时再改变

---
#### I2C的流程
分为四步 ***起始位 寻址 数据传输 停止位***
>### 起始:
>	由于上拉电阻,SCL与SDA都是高电压,主机先主动下拉SDA作为起始位

>### 寻址:
>	主机向总线发送从机地址,从主机开始向SDA写入数据的瞬间,SCL激活~也即被拉低~,然后开始锯齿状传输时钟信号.	常用是7位地址.剩下的一位^R/W#,井号代表低电压有效,即0写1读^代表数据传输的方向,随后主机释放SDA等待从机应答,从机把SDA拉低发送应答信号ACK(acknowledge)

这里可能会想,如果从机是0x11的话,岂不是最后一位冲突了?需要注意的是,从机的地址我们就是设计为了7位,并不是按照字节为单位,``用十六进制描述从机地址时,默认它代表的是 7 位二进制数.``也即0x11 -> 十进制17 -> 七位二进制0001001
>
>在从机应答过程中,可能无法ACK,这称为NAK,寻址失败有这些可能
>- 地址错误
>- 从机忙
>- 从机故障

>### 数据接收
>以字节为单位,同样是发送方结束后拉高,等待接收方拉低SDA作为ACk信号.

>### 停止位
>由主机发送,在SCL为1时,向SDA发送上升沿信号结束.

### 程序部分

引入新的函数:
```c
HAL_I2C_Master_Transmit(*hi2c , DevAddress , *pData , Size , Timeout)

举例,为了点亮oled,要对其初始化发送一串数据
uint8_t commands = {0x00 , 0x8d, ....};
HAL_I2C_Master_Transmit(&hi2c1 , 0x78 , commands , sizeof(commands)/sizeof(commands[0]) , HAL_MAX_DELAY);

```

### 按键与输入获取

----
依旧初始化
```c
RCC_APB2PeriphClockCmd ( RCC_APB2Periph_GPIOB , ENABLE ) ;

GPIO_InitTypeDef GPIO_InitStructure ; 
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU	///上啦输入
pin...
speed...
GPIO_Init ( GPIOB ,  &GPIO_InitStructure) ;


```
然后需要实现函件输入获取:

```c
uint8_t Key_GetNum (void)
{
u8 KeyNum = 0 ;
///GPIO.h的最后存放着这些读取函数,具体有四个,分别对应读取输入/输出的全部/某一位,这里需要输入的一个值
if(
GPIO_ReadInputDataBit ( GPIOB , GPIO_Pin1 ) == 0
)
	{
	Delay_ms(20);
	*再次判断*
	Delay_ms(20);
	KeyNum = 1 ; 
	}


retrun KeyNum;
}


```

这里其实还可以使用读取输出来翻转状态
>if (GPIO_ReadOutputDataBit ( GPIOA , GPIO_Pin_1 ) == 0)  ;


## 中断
中断原理和机制这里不赘述了。

#### 中断的地址：
> 因为中断函数的地址依靠编译器来分配，不固定，但是中断跳转又需要确切的地址，因此有了中断向量表，本质上是一个列表地址，在固定地址由编译器把它引导到中断函数的地址去，在C语言中自动完成。

#### NVIC
> 用于统一接收外设的中断通道，根据优先级分配中断先后，最后靠仅有的一根输出线给予CPU执行的中断函数与优先级顺序。优先级由优先级寄存器的4位（0-15）决定，具体又分为响应优先级（低4-n位）和可以中断嵌套的抢占优先级（n位）。也就是说，可能的组合有五种，（0,4）（1,3）（2,2）（3,1）（4,0）

### EXIT（extern interrupt外部中断）

![输入图片说明](/imgs/2025-10-21/c1G9AETOnrB41v3Q.png)
支持所有GPIO口，但是PA0，PB0这样Pin相同的不能同时中断。（因为中断引脚选择AFIO  只有16Pin）

触发响应方式：中断响应、事件响应（触发事件，中断事件流向其他外设而非CPU）

通道数：16GPIO_Pin + 4个其他的（连接在中断引脚选择之后）

配置中断过程：
依次配置RCC，GPIO（输入模式），AFIO，EXTI与触发方式等，NVIC（配置中断优先级）

```c
void CountSensor_Init(void)
{
RCC_APB2PeriphClockCMD(RCC_APB2Periph_GPIOB , ENABLE) ;
RCC_APB2PeriphClockCMD(RCC_APB2Periph_AFIO , ENABLE) ; 
///EXTI与NVIC是默认开启的

GPIO_InitTypeDed GPIO_InitStructrue;
///具体怎么配.可以去参考手册的GPIO篇章查找对应外设的配置模式
GPIO_InitStructrue.GPIO_Mode = GPIO_Mode_IPU;
GPIO_InitStructrue.GPIO_Pin = GPIO_Pin_14 ; 
GPIO_InitStructrue.GPIO_Speed = GPIO_Speed_50Hz ;
GPIO_Init(GPIOB , &GPIO_InitStructrue ) ;

//  GPIO_EXITLineConfig(u8 GPIO_PortSource , u8 GPIO_PinSource) ;
GPIO_EXITLineConfig(u8 GPIO_PortSourceGPIOB , u8 GPIO_PinSource14) ; ////依旧是,怎么填? 抄定义
///上一步实现了AFIO第十四个输入选择器设置,输入端设置到GPIOB的外设PB14，输出端固定在EXIT14

///接下来初始化EXTI外部中断,与GPIO的初始化类似,也是结构体
EXTI_InitTypeDef EXIT_InitStructure ;
EXIT_InitStructure.EXIT_Line = EXIT_Line14 ; 
EXIT_InitStructure .EXIT_Linecmd = ENABLE ; 
EXIT_InitStructure .EXIT_Mode = EXIT_Mode_Interrupt ; (事件\中断模式)
EXIT_InitStructure.Trigger = EXTI_Trigger_Falling ; 
EXTI_Init(&EXIT_InitStructure );

NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); ///设置几位抢占几位响应的优先级


NVIC_InitTypeDef NVIC_InitStructure ; 
NVIC_InitStructure.NVIC_IRQChannel = EXIT_15_10_IRQn ;
NVIC_InitStructure.NVIC_IRQChannelCmd =  ENABLE ; 
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1; 

NVIC_Init( &NVIC_InitStructure );
}

```

以上代码实现了外部中断信号从GPIO到AFIO到EXTI到NVIC最后CPU的配置。之后我们需要配置中断函数，在STM32中，每个终端通道对应的函数是固定的，具体可在Start的start_up文件查询中断向量表。
```c
void EXIT15_10_IQRHandler(void)
{
//先判断一下是不是我们想要的14通道
if( EXTI_GetITStatus(EXIT_Line14) == SET )
	{
	**要执行的内容**
	EXIT_ClearITPendingBir(EXIT_Line14);
	//如果不清除中断标志位,程序将会一直申请中断
	}

}

```
我们现在更换一下视角,如果使用的不是接在PB14的传感器,而是连在PB0和1的旋转编码器,代码又如何？
```c
GPIO部分--
GPIO_InitStructrue.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_0 ; 

AFIO--
GPIO_EXITLineConfig(u8 GPIO_PortSourceGPIOB , u8 GPIO_PinSource0) ;
GPIO_EXITLineConfig(u8 GPIO_PortSourceGPIOB , u8 GPIO_PinSource1) ;

EXTI--
EXIT_InitStructure.EXIT_Line = EXIT_Line0 | EXTI_Line1 ; 

NVIC--
复制两份,分别配置优先级
```
中断函数:
```c
void EXTI0_IRQHandler(void)
{
if( EXTI_GetITStatus(EXIT_Line0) == SET )
	{
	**要执行的内容**
	///这里旋转编码器需要依靠(我的沿变化时对方的高低电平)来判断是正是反
	{
	if(GPIO_ReadInputDataBit (GPIB,GPIO_0) == 0 )
		{Encoder_Count--;}
	}
	
	EXIT_ClearITPendingBir(EXIT_Line0);
	//如果不清除中断标志位,程序将会一直申请中断
	}

下 EXTI1 同.

}

```

<!--stackedit_data:
eyJoaXN0b3J5IjpbLTgxMTM3Nzk3MCwxODkyOTc5MTQ5LDExMT
UzNTQ1NzUsNjYxMTU1MTQ0LC00MjE2NDYzMCwtMTc0Mjg3MjM3
NywtNTE0NTk2NTA1LC0yMDc5MjY4MDIxLC00NDg1NjMyMTNdfQ
==
-->